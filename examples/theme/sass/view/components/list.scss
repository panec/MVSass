@import "../../ref";

//Params to be extended
@mixin mvs-respond-map( $prefix, $map, $selector: null, $depth: 0 ) {
	$prefixLength: str-length( $prefix );

	@each $key, $value in $map {
		@if str-index( $key, $prefix ) != null {
			$property: str-slice( $key, $prefixLength + 1 );
			@if ( str-index-last( $property, "_" ) == false ) {
				//TODO Add logic to recognize custom mixin map from extended nth syntax map
				@if ( mixin-exists( $property ) ) {
					@debug $property this is a supported mixin;
					// @include mvs-respond-property-list( str-slice( $key, $prefixLength + 1 ), $value, $selector, $depth );
				}
				@else {
					@include mvs-respond-property( str-slice( $key, $prefixLength + 1 ), $value, $selector, $depth );
				}
			}
		}
	}
}

@mixin mvs-respond-property( $property, $values, $selector: null, $depth: 0 ) {
	$screenBreakpointsKeys : map-keys( $screen-breakpoints );

	@if $values == null {
		//skip
	}
	@else if is( $property, "font-family" "font" ) {
		@warn "MVS syntax does not support #{$property} property";
		@include -mvs-respond( $property, $values, $selector, $depth );
	}
	@else {
		$values: normalize-value( $values );

		@each $value in $values {

			// @debug " $value " length( $value ) $value;
			// 1 - at body value
			$_1: to-string( map-get( $value, "_1" ) );
			// 2 - at element value
			$_2: to-string( map-get( $value, "_2" ) );
			// 3 - at list container value
			$_3: to-string( map-get( $value, "_3" ) );
			// 4 - at block value ( for modifiers )
			// $_4: to-string( map-get( $value, "_4" ) );

			#{$_1} &#{$_2}{
				@include -mvs-respond( $property, map-get( $value, "initial" ), $selector, $depth, $_3 );
			}

			@each $breakpoint in $screenBreakpointsKeys {
				@include respond-to( $breakpoint ) {
					#{$_1} &#{$_2}{
						@include -mvs-respond( $property, map-get( $value, $breakpoint ), $selector, $depth, $_3 );
					}
				}
			}
		}
	}
}

@mixin respond-to( $breakpoint, $is-specific: false ) {
	@if $is-specific {
		$index: map-index( $screen-breakpoints, $breakpoint );

		@if $index < length( $screen-breakpoints ) {
			//loosly based on https://raw.githubusercontent.com/guardian/sass-mq/master/_mq.scss
			$max-width-unit: unit( map-nth( $screen-breakpoints, $index + 1 ) );
			@media only screen and ( min-width:  map-get( $screen-breakpoints, $breakpoint ) ) and ( max-width: if( $max-width-unit == "px" , map-nth( $screen-breakpoints, $index + 1 ) - 1, map-nth( $screen-breakpoints, $index + 1 ) - .01 ) ) { @content; }
			// @media only screen and ( min-width:  map-get( $screen-breakpoints, $breakpoint ) ) and ( max-width: map-nth( $screen-breakpoints, $index + 1 ) - 1 ) { @content; }
		}
		@else {
			@media only screen and ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) { @content; }
		}
	}
	@else {
		@media only screen and ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) { @content; }
	}
}

//done
@function normalize-value( $value ) {
	$resultList            : ();
	$screenBreakpointsKeys : map-keys( $screen-breakpoints );
	$valueSyntaxType       : check-value-syntax-type( $value );

	// 0 - simple css value list
	@if $valueSyntaxType == 0 {
		$resultList: append( $resultList, ( "initial": $value ) );
	}
	// 1 - mvsass list of comma seperated optional modifiers & list of values
	@else if $valueSyntaxType == 1 {
		$map: ();
		$screenBreakpointsKeysIndex: 1;

		@each $subValue in $value {
			@if mvs-value-position( $subValue ) == 0 {
				@if $screenBreakpointsKeysIndex == 1 {
					$map: map-merge( $map, ( "initial": $subValue ) );
				}
				@else {
					$map: map-merge( $map, ( nth( $screenBreakpointsKeys, $screenBreakpointsKeysIndex ): $subValue ) );
				}
				$screenBreakpointsKeysIndex: $screenBreakpointsKeysIndex + 1;
			}
			@else if mvs-value-position( $subValue ) == 1 {
				$subMap: map-get( $map, "_1" );
				$map: map-merge( $map, ( "_1": if( $subMap == null, $subValue, append( $subMap, $subValue, space ) ) ) );
			}
			@else if mvs-value-position( $subValue ) == 2 {
				$subMap: map-get( $map, "_2" );
				$map: map-merge( $map, ( "_2": if( $subMap == null, $subValue, append( $subMap, $subValue, space ) ) ) );
			}
			@else if mvs-value-position( $subValue ) == 3 {
				$subMap: map-get( $map, "_3" );
				$map: map-merge( $map, ( "_3": if( $subMap == null, $subValue, append( $subMap, $subValue, space ) ) ) );
			}
		}

		$resultList: append( $resultList, $map );
	}
	// 2 - mvsass map of values
	@else if $valueSyntaxType == 2 {
		$resultList: append( $resultList, $value );
	}
	// 3 - mvsass list of comma seperated modifiers & map of values
	@else if $valueSyntaxType == 3 {
		$map: ();

		@each $subValue in $value {
			@if mvs-value-position( $subValue ) == 0 {
				$map: map-merge( $map, $subValue );
			}
			@else if mvs-value-position( $subValue ) == 1 {
				$subMap: map-get( $map, "_1" );
				$map: map-merge( $map, ( "_1": if( $subMap == null, $subValue, append( $subMap, $subValue, space ) ) ) );
			}
			@else if mvs-value-position( $subValue ) == 2 {
				$subMap: map-get( $map, "_2" );
				$map: map-merge( $map, ( "_2": if( $subMap == null, $subValue, append( $subMap, $subValue, space ) ) ) );
			}
			@else if mvs-value-position( $subValue ) == 3 {
				$subMap: map-get( $map, "_3" );
				$map: map-merge( $map, ( "_3": if( $subMap == null, $subValue, append( $subMap, $subValue, space ) ) ) );
			}
		}

		$resultList: append( $resultList, $map );
	}
	// 4 - nested syntax
	@else if $valueSyntaxType == 4 {
		@each $subValue in $value {
			$resultList: join( $resultList, normalize-value( $subValue ) );
		}
	}

	@return $resultList;
}

//done
// 0 - simple css value list
// 1 - mvsass list of comma seperated optional modifiers & list of values
// 2 - mvsass map of values
// 3 - mvsass list of comma seperated modifiers & map of values on last one
// 4 - nested syntax
@function check-value-syntax-type( $syntax ) {
	$result: 0;

	@if ( type-of( $syntax ) == "list" and list-separator( $syntax ) == "comma" ) {
		$result: 1;

		@each $listItem in $syntax {
			$subSyntax: check-value-syntax-type( $listItem );
			@if $subSyntax != 0 {
				$result: 4;
			}
		}

		@if type-of( nth( $syntax, -1 ) ) == "map" {
			@each $listItem in slice( $syntax, 1, length( $syntax ) - 1 ) {
				$subSyntax: check-value-syntax-type( $listItem );
				@if $subSyntax == 0 {
					$result: 3;
				}
			}
		}
	}
	@else if type-of( $syntax ) == "map" {
		$result: 2;
	}

	@return $result;
}

//done
// return
// 0 - not specific value
// 1 - at body value
// 2 - at element value
// 3 - at list container value
// 4 - at block value ( for modifiers )
@function mvs-value-position( $value ) {
	$atBody: ".flex" ".no-flex"; //TODO Fill modernizr & cssua values
	$atElement: ":hover" ":before" ":after"; //TODO Fill pseudo selectors & elements
	$atListElement: ":nth-child" ":nth-of-type" ":first-child" ":last-child";
	// $at-block: // This can be for mods


	//TODO this is a very big assumption
	@if type-of( $value ) == "map" and map-get( $value, "initial" ) == null {
		@return 4; //"at-block";
	}
	@else if type-of( $value ) != "string" {
		@return 0; //"at-value";
	}
	@else {
		@if is( $value, $atBody ) {
			@return 1; //"at-body";
		}
		@if is( $value, $atElement ) {
			@return 2; //"at-body";
		}
		//Cannot be is() because the nth syntax is not fixed
		@each $string in $atListElement {
			@if str-index( $value, $string ) {
				@return 3; //"at-list-element";
			}
		}

		@return 0; //"at-value";
	}
}

// @mixin list( $model-list: $core-model-list, $is-initial: false ) {
// 	.list-item {
// 		@include mvs-respond-map( "item_", $model-list );
// 	}
// }

// .syntax_base {
// 	@include list( $theme-model-list-component_syntax_base );
// }

// .syntax_base_list {
// 	@include list( $theme-model-list-component_syntax_base_list );
// }

// .syntax_base_map {
// 	@include list( $theme-model-list-component_syntax_base_map );
// }

// .syntax_base_modernizr {
// 	@include list( $theme-model-list-component_syntax_base_modernizr );
// }

// .syntax_base_list_modernizr {
// 	@include list( $theme-model-list-component_syntax_base_list_modernizr );
// }

// .syntax_base_map_modernizr_single {
// 	@include list( $theme-model-list-component_syntax_base_map_modernizr_single );
// }

// .syntax_base_map_modernizr {
// 	@include list( $theme-model-list-component_syntax_base_map_modernizr );
// }

// .syntax_base_modernizr_nth {
// 	@include list( $theme-model-list-component_syntax_base_modernizr_nth );
// }

// .syntax_base_list_modernizr_nth_multi {
// 	@include list( $theme-model-list-component_syntax_base_list_modernizr_nth_multi );
// }

// .syntax_base_map_modernizr_nth {
// 	@include list( $theme-model-list-component_syntax_base_map_modernizr_nth );
// }

// .syntax_base_modernizr_nth_multi {
// 	@include list( $theme-model-list-component_syntax_base_modernizr_nth_multi );
// }

// .syntax_base_list_modernizr_nth_multi {
// 	@include list( $theme-model-list-component_syntax_base_list_modernizr_nth_multi );
// }

// .syntax_base_modernizr_nth_pseudo {
// 	@include list( $theme-model-list-component_syntax_base_modernizr_nth_pseudo );
// }

// .syntax_base_list_modernizr_nth_pseudo {
// 	@include list( $theme-model-list-component_syntax_base_list_modernizr_nth_pseudo );
// }

// .syntax_base_map_modernizr_nth_pseudo {
// 	@include list( $theme-model-list-component_syntax_base_map_modernizr_nth_pseudo );
// }

.syntax_base_modernizr_nth_pseudo_mod {
	@include list( $theme-model-list-component_syntax_base_modernizr_nth_pseudo_mod );
}

.syntax_base_list_modernizr_nth_pseudo_mod {
	@include list( $theme-model-list-component_syntax_base_list_modernizr_nth_pseudo_mod );
}

.syntax_base_map_modernizr_nth_pseudo_mod {
	@include list( $theme-model-list-component_syntax_base_map_modernizr_nth_pseudo_mod );
}
