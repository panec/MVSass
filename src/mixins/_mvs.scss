//**
// MVS mixins

//**
// Private mixin for handling rendering css with Compass mixins
// Params
// 	$property (Sass::Script::Value::String)
// 	$value (Sass::Script::Value::Base)
@mixin -mvs-respond-compass( $property, $value ) {
	//https://github.com/nex3/sass/issues/626#issuecomment-39012395 Feature under consideration SASS 3.4
	// @if mixin-exists( $property ) {
	// 	@include #{ $property }( $value );
	// }

	//TODO: Add full list of Compass mixins
	$mvsRespondMixinsGenerated: true !global;

	@if $property == "background" and mixin-exists( $property ){
		@include background( $value );
	}
	@else if $property == "background-image" and mixin-exists( $property ) {
		@include background( $value );
	}
	@else if $property == "ellipsis" and mixin-exists( $property ) {
		@include ellipsis( $value );
	}
	@else if $property == "display-flex" and mixin-exists( $property ) {
		@include display-flex();
	}
	@else if $property == "flex-direction" and mixin-exists( $property ) {
		@include flex-direction( $value );
	}
	@else if $property == "user-select" and mixin-exists( $property ) {
		@include user-select( $value );
	}
	@else {
		$mvsRespondMixinsGenerated: false !global;
	}
}

//**
// Private mixin for iterating thru all custom mixin libraries
// Params
// 	$property (Sass::Script::Value::String)
// 	$value (Sass::Script::Value::Base)
@mixin -mvs-respond-mixins( $property, $value ) {
	@if $value != null {
		$mvsRespondMixinsGenerated: false !global;

		@if $mvsRespondMixinsGenerated == false and mixin-exists( "mvs-respond-custom" ) {
			@include mvs-respond-custom( $property, $value );
		}

		@if $mvsRespondMixinsGenerated == false {
			@include -mvs-respond-compass( $property, $value );
		}

		@if $mvsRespondMixinsGenerated == false {
			#{$property}: $value;
		}
	}
}

//**
// Calls mvs-respond-propetry-list mixin against all keys in $map that contain only $prefix and css property
// Params
// 	$elementPrefix (Sass::Script::Value::String)
// 	$valueMap (Sass::Script::Value::Base)
// 	$selector (Sass::Script::Value::String)
// 	$depth (Sass::Script::Value::Number)
// Example
// 	mvs-respond-map( "list-item", $map );
//TODO Params to be extended
@mixin mvs-respond-map( $elementPrefix, $valueMap, $parentBlockSelector: null, $parentBlockDepth: -1, $parentListSelector: null, $parentListDepth: -1 ) {
	$elementPrefixLength: str-length( $elementPrefix );

	@each $key, $value in $valueMap {
		@if str-index( $key, $elementPrefix ) != null {
			$property: str-slice( $key, $elementPrefixLength + 1 );
			@if ( str-index-last( $property, "_" ) == false ) {
				// @if ( mixin-exists( $property ) and type-of( $value ) == "map" ) {
				// TODO Add support for custom-mixins
				// @if mixin-exists( $property ) {
				// 	@debug $property is a supported mixin;
				// 	@include -mvs-respond-mixins( $property, $value );
				// }
				// @else {
					@include mvs-respond-property( str-slice( $key, $elementPrefixLength + 1 ), $value, $parentBlockSelector, $parentBlockDepth, $parentListSelector, $parentListDepth );
				// }
			}
		}
	}
}

//TODO Add examples and desciption
@mixin mvs-respond-property( $property, $values, $parentBlockSelector: null, $parentBlockDepth: 1, $parentListSelector: null, $parentListDepth: 1 ) {
	@if $values == null {
		//skip
	}
	@else if is( $property, "font-family" "font" ) {
		@warn "MVS syntax does not support #{$property} property";
		@include -mvs-respond-mixins( $property, $values );
	}
	@else {
		@debug "VALUES " $values;

		$values                : mvs-normalize-value( $values );
		$screenBreakpointsKeys : join( "initial", map-keys( $screen-breakpoints ) );

		@debug "VALUES NORMALIZED" $values;

		@each $value in $values {
			// 1 - at body value
			$_1: to-string( map-get( $value, "_1" ) );
			// 2 - at element value
			$_2: to-string( map-get( $value, "_2" ) );
			// 3 - at list container value
			$_3: to-string( map-get( $value, "_3" ) );
			// 4 - at block value ( for modifiers )
			$_4: mvs-mod-to-string( map-get( $value, "_4" ), "mod", "data" );
			// 5 - media type for @media
			// $_5: to-string( map-get( $value, "_5" ), " and " );
			$_5: map-get( $value, "_5" );
			@if length( $_5 ) > 1 {
				@debug "Due limitation of interpolation in SASS @media only first value of `#{$_5}` will be added";
				$_5: nth( $_5, 1 );
			}

			// @debug "dolar_3: " #{map-get( $value, "_3" )} "|" map-get( $value, "_3" ) == null "|" type-of($_3) "|" $_3 != "";

			// @debug "type-of map get null: " type-of( map-get( (), abc ) );
			// @debug "_3 is value: " map-get( $value, "_3" ) " is null: " map-get( $value, "_3" ) == null " type-of: " type-of($_3);

			@each $breakpoint in $screenBreakpointsKeys {
				#{$_1} &#{$_2}{
					@include respond-to( $breakpoint, $_3 != "", $_5 ) {
						@include mvs-parent-inject( "#{$parentBlockSelector}#{$_4}", false, if( $_4 != "", $parentBlockDepth, -1 ) ) {
							@include mvs-parent-inject( "#{$parentListSelector}#{$_3}", true, if( $_3 != "", $parentListDepth, -1 ) ) {
								@include -mvs-respond-mixins( $property, map-get( $value, $breakpoint ) );
							}
						}
					}
				}
			}
		}
	}
}

//**
// Generates styles for screen size bigger then defined breakpoint,
// If $is-specific is true then generates styles only for the defined breakpoint
// Params
// 	$breakpoint (Sass::Script::Value::String)
// 	$is-specific (Sass::Script::Value::Bool)
// Example
// 	respond-to( xs ) { color: #FFF; } => @media only screen and ( min-width: 480px ) { color: #FFF; }
// 	respond-to( xs, $is-specific: true ) { color: #FFF; } => @media only screen and ( min-width: 480px ) and ( max-width: 767px ) { color: #FFF; }
//TODO Update description
@mixin respond-to( $breakpoint: "initial", $is-specific: false, $mediaType: "" ) {

	@if length( $mediaType ) > 1 {
		@debug "Due limitation of interpolation in SASS at @media only single value are supported for $mediaType but was `#{$mediaType}`";
	}

	@if $breakpoint == "initial" or $breakpoint == nth( map-keys( $screen-breakpoints ), 1 ) {
		@if $mediaType == null or $mediaType == "" {
			@content;
		}
		@else {
			@media #{ $mediaType } { @content; }
		}
	}
	@else if $is-specific {
		$index: map-index( $screen-breakpoints, $breakpoint );

		@if $index < length( $screen-breakpoints ) {
			//loosly based on https://raw.githubusercontent.com/guardian/sass-mq/master/_mq.scss
			$max-width-unit: unit( map-nth( $screen-breakpoints, $index + 1 ) );

			@if $mediaType == null or $mediaType == "" {
				@media ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) and ( max-width: if( $max-width-unit == "px" , map-nth( $screen-breakpoints, $index + 1 ) - 1, map-nth( $screen-breakpoints, $index + 1 ) - .01 ) ) { @content; }
			}
			@else {
				@media #{ $mediaType } and ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) and ( max-width: if( $max-width-unit == "px" , map-nth( $screen-breakpoints, $index + 1 ) - 1, map-nth( $screen-breakpoints, $index + 1 ) - .01 ) ) { @content; }
			}
		}
		@else {
			@if $mediaType == null or $mediaType == "" {
				@media ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) { @content; }
			}
			@else {
				@media #{ $mediaType } and ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) { @content; }
			}
		}
	}
	@else {
		@if $mediaType == null or $mediaType == "" {
			@media ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) { @content; }
		}
		@else {
			@media #{ $mediaType } and ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) { @content; }
		}
	}
}

//Based on http://sassmeister.com/gist/7786284
//http://www.youtube.com/watch?feature=player_detailpage&v=-ZJeOJGazgE#t=1846

//**
// Injects or appends $selector into parent selector on position defined by $depth starting from last
// Params
// 	$selector (Sass::Script::Value::String)
// 	$inject (Sass::Script::Value::Bool)
// 	$depth (Sass::Script::Value::Number)
// Example
// 	.parent .item { mvs-parent-inject( ":hover", true ) } => .parent .item :hover
// 	.parent .item { mvs-parent-inject( ":hover", false ) } => .parent .item:hover
// 	.parent .item { mvs-parent-inject( " .test", true ) } => .parent .item .test
// 	.parent .item { mvs-parent-inject( ":hover", false, 1 ) } => .parent .item:hover
// 	.parent .item { mvs-parent-inject( " .test", true, 1 ) } => .parent .test .item
@mixin mvs-parent-inject( $selector, $inject: true, $depth: 0 ) {
	@if $depth > 0 {
		@at-root {
			$path: mvs-parent();

			@if $inject {
				#{insert-nth( $path, length( $path ) - $depth + 1, unquote( $selector ) )} { @content; }
			}
			@else {
				#{replace-nth( $path, length( $path ) - $depth, nth( $path, length( $path ) - $depth ) + unquote( $selector ) )} { @content; }
			}
		}
	}
	@else if $depth == 0 {
		&#{$selector} { @content; }
	}
	@else {
		@content;
	}
}
