//**
// MVS mixins

//**
// Private mixin for handling rendering css with Compass mixins
// Params
// 	$property (Sass::Script::Value::String)
// 	$value (Sass::Script::Value::Base)
@mixin -mvs-respond-compass( $property, $value ) {
	//https://github.com/nex3/sass/issues/626#issuecomment-39012395 Feature under consideration SASS 3.4
	// @if mixin-exists( $property ) {
	// 	@include #{ $property }( $value );
	// }

	//TODO: Add full list of Compass mixins
	$mvsRespondMixinsGenerated: true !global;

	@if $property == "background" and mixin-exists( $property ){
		@include background( $value );
	}
	@else if $property == "background-image" and mixin-exists( $property ) {
		@include background( $value );
	}
	@else if $property == "ellipsis" and mixin-exists( $property ) {
		@include ellipsis( $value );
	}
	@else if $property == "display-flex" and mixin-exists( $property ) {
		@include display-flex();
	}
	@else if $property == "flex-direction" and mixin-exists( $property ) {
		@include flex-direction( $value );
	}
	@else if $property == "user-select" and mixin-exists( $property ) {
		@include user-select( $value );
	}
	@else {
		$mvsRespondMixinsGenerated: false !global;
	}
}

//**
// Private mixin for iterating thru all custom mixin libraries
// Params
// 	$property (Sass::Script::Value::String)
// 	$value (Sass::Script::Value::Base)
@mixin -mvs-respond-mixins( $property, $value ) {
	$mvsRespondMixinsGenerated: false !global;

	@if $mvsRespondMixinsGenerated == false and mixin-exists( "mvs-respond-custom" ) {
		@include mvs-respond-custom( $property, $value );
	}

	@if $mvsRespondMixinsGenerated == false {
		@include -mvs-respond-compass( $property, $value );
	}

	@if $mvsRespondMixinsGenerated == false {
		#{$property}: $value;
	}
}

//**
// Calls mvs-respond-propetry-list mixin against all keys in $map that contain only $prefix and css property
// Params
// 	$elementPrefix (Sass::Script::Value::String)
// 	$valueMap (Sass::Script::Value::Base)
// 	$selector (Sass::Script::Value::String)
// 	$depth (Sass::Script::Value::Number)
// Example
// 	mvs-respond-map( "list-item", $map );
//TODO Params to be extended
@mixin mvs-respond-map( $elementPrefix, $valueMap, $parentBlockSelector: null, $parentBlockDepth: -1, $parentListSelector: null, $parentListSDepth: -1 ) {
	$elementPrefixLength: str-length( $elementPrefix );

	@each $key, $value in $valueMap {
		@if str-index( $key, $elementPrefix ) != null {
			$property: str-slice( $key, $elementPrefixLength + 1 );
			@if ( str-index-last( $property, "_" ) == false ) {
				//TODO Add logic to recognize custom mixin map from extended nth syntax map
				@if ( mixin-exists( $property ) and type-of( $value ) == "map" ) {
					@debug $property this is a supported mixin that has a map values ;
					// @include mvs-respond-property-list( str-slice( $key, $elementPrefixLength + 1 ), $value, $selector, $depth );
				}
				@else {
					@include mvs-respond-property( str-slice( $key, $elementPrefixLength + 1 ), $value, $parentBlockSelector, $parentBlockDepth, $parentListSelector, $parentListSDepth );
				}
			}
		}
	}
}

//TODO Add examples and desciption
@mixin mvs-respond-property( $property, $values, $parentBlockSelector: null, $parentBlockDepth: 1, $parentListSelector: null, $parentListDepth: 1 ) {
	$screenBreakpointsKeys : map-keys( $screen-breakpoints );

	@if $values == null {
		//skip
	}
	@else if is( $property, "font-family" "font" ) {
		@warn "MVS syntax does not support #{$property} property";
		@include -mvs-respond-mixins( $property, $values );
	}
	@else {
		$values: mvs-normalize-value( $values );
		@debug NORMALIZED $values;

		@each $value in $values {
			// 1 - at body value
			$_1: to-string( map-get( $value, "_1" ) );
			// 2 - at element value
			$_2: to-string( map-get( $value, "_2" ) );
			// 3 - at list container value
			$_3: to-string( map-get( $value, "_3" ) );
			// 4 - at block value ( for modifiers )
			$_4: mvs-mod-to-string( map-get( $value, "_4" ), "", "data" );

			#{$_1} &#{$_2}{
				@include mvs-parent( "#{$parentBlockSelector}#{$_4}", false, if( $_4 != "", $parentBlockDepth, -1 ) ) {
					@include mvs-parent( "#{$parentListSelector}#{$_3}", true, if( $_3 != "", $parentListDepth, -1 ) ) {
						@include -mvs-respond-mixins( $property, map-get( $value, "initial" ) );
					}
				}
			}

			@each $breakpoint in $screenBreakpointsKeys {
				#{$_1} &#{$_2}{
					@include respond-to( $breakpoint, $_3 != "" ) {
						@include mvs-parent( "#{$parentBlockSelector}#{$_4}", false, if( $_4 != "", $parentBlockDepth, -1 ) ) {
							@include mvs-parent( "#{$parentListSelector}#{$_3}", true, if( $_3 != "", $parentListDepth, -1 ) ) {
								@include -mvs-respond-mixins( $property, map-get( $value, $breakpoint ) );
							}
						}
					}
				}
			}
		}
	}
}

//**
// Generates styles for screen size bigger then defined breakpoint,
// If $is-specific is true then generates styles only for the defined breakpoint
// Params
// 	$breakpoint (Sass::Script::Value::String)
// 	$is-specific (Sass::Script::Value::Bool)
// Example
// 	respond-to( xs ) { color: #FFF; } => @media only screen and ( min-width: 480px ) { color: #FFF; }
// 	respond-to( xs, $is-specific: true ) { color: #FFF; } => @media only screen and ( min-width: 480px ) and ( max-width: 767px ) { color: #FFF; }
@mixin respond-to( $breakpoint, $is-specific: false ) {
	@if $is-specific {
		$index: map-index( $screen-breakpoints, $breakpoint );

		@if $index < length( $screen-breakpoints ) {
			//loosly based on https://raw.githubusercontent.com/guardian/sass-mq/master/_mq.scss
			$max-width-unit: unit( map-nth( $screen-breakpoints, $index + 1 ) );
			@media only screen and ( min-width:  map-get( $screen-breakpoints, $breakpoint ) ) and ( max-width: if( $max-width-unit == "px" , map-nth( $screen-breakpoints, $index + 1 ) - 1, map-nth( $screen-breakpoints, $index + 1 ) - .01 ) ) { @content; }
		}
		@else {
			@media only screen and ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) { @content; }
		}
	}
	@else {
		@media only screen and ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) { @content; }
	}
}

//Based on http://sassmeister.com/gist/7786284
//http://www.youtube.com/watch?feature=player_detailpage&v=-ZJeOJGazgE#t=1846

//**
// Injects or appends $selector into parent selector on position defined by $depth starting from last
// Params
// 	$selector (Sass::Script::Value::String)
// 	$inject (Sass::Script::Value::Bool)
// 	$depth (Sass::Script::Value::Number)
// Example
// 	.parent .item { mvs-parent( ":hover", true ) } => .parent .item :hover
// 	.parent .item { mvs-parent( ":hover", false ) } => .parent .item:hover
// 	.parent .item { mvs-parent( " .test", true ) } => .parent .item .test
// 	.parent .item { mvs-parent( ":hover", false, 1 ) } => .parent .item:hover
// 	.parent .item { mvs-parent( " .test", true, 1 ) } => .parent .test .item
@mixin mvs-parent( $selector, $inject: true, $depth: 0 ) {
	@if $depth > 0 {
		@at-root {
			$path: "";

			// Custom ruby script, because SASS 3.4 do not resolves '&' for scripts
			@if function-exists( parentsSelector ) {
				$path: nth( parentsSelector(), 1 );
			}
			@else if type-of( & ) == "list" {
				$path: nth( &, 1 );
			}
			@else {
				@debug "Function 'parentsSelector' does not exist. Check if your project uses custom Ruby script provided, or update to SASS 3.4.x";
			}

			@if $inject {
				#{insert-nth( $path, length( $path ) - $depth + 1, unquote( $selector ) )} { @content; }
			}
			@else {
				#{replace-nth( $path, length( $path ) - $depth, nth( $path, length( $path ) - $depth ) + unquote( $selector ) )} { @content; }
			}
		}
	}
	@else if $depth == 0 {
		&#{$selector} { @content; }
	}
	@else {
		@content;
	}
}
