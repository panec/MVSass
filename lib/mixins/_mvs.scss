/**
 * MVS mixins
 */

/**
 * Private mixin for handling rendering css properties with values
 * Params
 * 	$property (Sass::Script::Value::String)
 * 	$value (Sass::Script::Value::Base)
 */
@mixin -mvs-respond( $property, $value ) {
	// @if is-array-numeric($value) {
	// 	@include rem-fallback($property, $value);
	// }
	@if mixin-exists( $property ) {
		@include #{ $property }( $value );
	}
	@else {
		#{$property}: $value;
	}
}




/**
 * Generates styles for property in MVS syntax
 * $selector defines parent selector to inject if MVS nth notation was used, if "" result will be appended
 * $depth defines how many parent selectors skip to inject $selector
 * Params
 * 	$property (Sass::Script::Value::String)
 * 	$values (Sass::Script::Value::Base)
 * 	$selector (Sass::Script::Value::String)
 * 	$depth (Sass::Script::Value::Number)
 * Example
 * 	mvs-respond( "border-width", 1px, ( 1px, 1px, 2px ) );
 * 	mvs-respond( "border-width", 1px, ( 1px, 1px, 2px ), " li" );
 * 	mvs-respond( "border-width", 1px, ( 1px, 1px, 2px ), " li", 1 );
 * 	mvs-respond( "border-width", 1px, ( 1px, 1px, 2px ), "", 1 );
 */
@mixin mvs-respond( $property, $values, $selector: null, $depth: 0 ) {
	//TODO Figure out proper syntax for this
	@if $property == "font-family" or $property == "font" {
		#{$property}: $values;
	}
	@else {
		//wrap "1px 1px 1px" syntax within comma seperated list to make it consistent
		$values       : if( list-separator($values) == "space", ( $values, ), $values );
		$length       : length($values);
		$defaultValue : nth($values, 1);

		@include -mvs-respond($property, $defaultValue);

		@if $length > 1 {
			@for $i from 2 through $length {
				$lastValue: $defaultValue;

				//can contain a list of viewport values as well as nth selectors with viewport values
				$subValues: nth($values, $i);
				$subLenght: length($subValues);

				//list of string values that are allowed in setting and will not trigger n-th selector
				// $nthStrings: "nth-child" "nth-of-type" "first-child" "last-child";
				// $isNthSyntax: if( type-of(nth($subValues, 1)) == "string", str-index-list(nth($subValues, 1), $nthStrings), false);
				$isNthSyntax: mvs-is-nth($subValues);
				$nthSelector: if( $isNthSyntax, nth( $subValues, 1 ), null );

				@if $isNthSyntax {
					$subValues: slice( $subValues, 2 );
					//This is for a mvs-get-nth syntax when it is nth syntax because all the values have to be called specifically
					$subLenght: length($screen-breakpoints-names);
				}

				@if $isNthSyntax == false and $defaultValue != nth( $subValues, 1 ){
					@warn "Default value" $defaultValue "is not equal to the first break point value" nth($subValues, 1);
				}

				@for $j from 1 through $subLenght {
					$currentValue: mvs-get-nth( $subValues, $j );

					// @if $isNthSyntax == false and $lastValue != $currentValue { //DOES NOT WORK, WHY????
					@if $isNthSyntax == false {
						@if $lastValue != $currentValue {
							$lastValue: $currentValue;
							@include respond-to( nth( $screen-breakpoints-names, $j ) ) {
								@include -mvs-respond($property, $lastValue);
							}
						}
					}
					@else {
						@include respond-to-specific( nth( $screen-breakpoints-names, $j ) ){
							@if ( type-of($selector) == "string" or type-of($selector) == "null" ) and $nthSelector != "" and $depth >= 0 {
								@if $selector == null or $selector == "" {
									@include append-parent("#{$selector}#{$nthSelector}", $depth) {
										@include -mvs-respond($property, $currentValue);
									}
								}
								@else {
									@include inject-parent("#{$selector}#{$nthSelector}", $depth) {
										@include -mvs-respond($property, $currentValue);
									}
								}
							}
							@else {
								@include -mvs-respond($property, $currentValue);
							}
						}
					}
				}
			}
		}
	}
}


/**
 * Calls mvs-respond mixin against all keys in $map that contain only $prefix and css property
 * Params
 * 	$prefix (Sass::Script::Value::String)
 * 	$map (Sass::Script::Value::Base)
 * 	$selector (Sass::Script::Value::Bool)
 * 	$depth (Sass::Script::Value::Number)
 * Example
 * 	mvs-respond-map( "list-item", $map );
 */
@mixin mvs-respond-map( $prefix, $map, $selector: null, $depth: 0 ) {
	$prefixLength: str-length( $prefix );

	@each $key, $value in $map {
		@if str-index($key, $prefix) != null {
			$property: str-slice( $key, $prefixLength + 1 );

			@if ( str-index-last( $property, "_" ) == false ){
				@include mvs-respond( str-slice( $key, $prefixLength + 1 ), $value, $selector, $depth );
			}
		}
	}
}

/**
 * Generates styles for screen size bigger then defined breakpoint,
 * If $isSpecific is true then generates styles only for the defined breakpoint
 * Params
 * 	$breakpoint (Sass::Script::Value::String)
 * 	$screen-breakpoints (Sass::Script::Value::Base)
 * 	$isSpecific (Sass::Script::Value::Bool)
 * Example
 * 	respond-to( xs ) { color: #FFF; } => @media only screen and ( min-width: 480px ) { color: #FFF; }
 * 	respond-to( xs, $isSpecific: true ) { color: #FFF; } => @media only screen and ( min-width: 480px ) and ( max-width: 767px ) { color: #FFF; }
 */
@mixin respond-to( $breakpoint, $screen-breakpoints: ( xxs : 0px, xs : 480px, sm : 768px, md : 992px, lg : 1200px ), $isSpecific: false) {
	@if $isSpecific {
		$index: map-index( $screen-breakpoints, $breakpoint )
		
		@if $index < length( $screen-breakpoints ) {
			@media only screen and ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) and ( max-width: map-nth( $screen-breakpoints, $index + 1 ) - 1 ) { @content; }
		}
		@else {
			@media only screen and ( min-width: map-get( $screen-breakpoints, $breakpoint ) ) { @content; }
		}
	}
	@else {
		@media only screen and ( max-width: map-get( $screen-breakpoints, $breakpoint ) ) { @content; }
	}
}